#! /bin/bash
#
# Run script for flywheel/hcp-func Gear.
#
# Authorship: Keith Jamison
#

##############################################################################
# Define directory names and containers

FLYWHEEL_BASE=/flywheel/v0
INPUT_DIR=$FLYWHEEL_BASE/input
OUTPUT_DIR=$FLYWHEEL_BASE/output
SCRIPT_DIR=${FLYWHEEL_BASE}/scripts
SCENE_DIR=${FLYWHEEL_BASE}/scenes
CONFIG_FILE=$FLYWHEEL_BASE/config.json
CONTAINER='[flywheel/hcp-func]'

source ${FLYWHEEL_BASE}/docker-env.sh

source ${SCRIPT_DIR}/bash_functions.sh # some useful tools

##############################################################################
# Parse configuration options

# If config.json exists, then we parse config file and cast vals to ENV Vars
# (Flywheel gear run). Otherwise we parse manifest.json and cast the values to
# ENV Vars from manifest (Docker run) Note value.default is used to grab the
# configured defaults.

if [[ -f $CONFIG_FILE ]]; then
  eval $(jq -r '.config | to_entries[] | "FW_CONFIG_\(.key)=\(.value)"' $CONFIG_FILE)
  eval $(jq -r '.inputs | to_entries[] | "FW_INPUT_\(.key)=\(.value.location.path)"' $CONFIG_FILE)
else
  CONFIG_FILE=$FLYWHEEL_BASE/manifest.json
  eval $(jq -r '.config | to_entries[] | "FW_CONFIG_\(.key)=\(.value.default)"' $CONFIG_FILE)
fi

##############################################################################
# use "echo" for testing arguments without running scripts
RUN_VOL=""
RUN_SURF=""
RUN_POST=""
RUN_QC=""

##############################################################################
# Set some pipeline defaults

source ${SCRIPT_DIR}/SetUpHCPPipeline.sh

StudyFolder=${OUTPUT_DIR}

PRINTCOM=""
QUEUE=""

LogFileDir=logs
LogFileDirFull=${OUTPUT_DIR}/${LogFileDir}
mkdir -p ${LogFileDirFull}
FSLSUBOPTIONS="-l ${LogFileDirFull}"

#Default Config Settings
UnwarpDir="" #must be correctly derived from metadata
DeltaTE="NONE" #DeltaTE for GRE fieldmap used to correct FUNCTIONAL
DwellTime="NONE" # DwellTime for BOTH fMRI and TOPUP SpinEchoFieldMap volumes

DistortionCorrection="NONE" # = Distortion correction for Functional pipeline (NONE, SiemensFieldMap, GeneralElectricFieldMap, TOPUP) 
# --> TOPUP requires SpinEchoPhaseEncodeNegative, SpinEchoPhaseEncodePositive
# --> FIELDMAP==SiemensFieldMap requires MagnitudeInputName, PhaseInputName
# --> GeneralElectricFieldMap requires GEB0InputName

GEB0InputName="NONE"
SpinEchoPhaseEncodeNegative="NONE"
SpinEchoPhaseEncodePositive="NONE"
MagnitudeInputName="NONE"
PhaseInputName="NONE"

fMRISBRef="NONE"
MCType="MCFLIRT"  #use "FLIRT" to run FLIRT-based mcflirt_acc.sh, or "MCFLIRT" to run MCFLIRT-based mcflirt.sh
BiasCorrection="NONE" # = bias field estimation for functional volumes (NONE, Legacy, SEBased)
# NONE = no bias correction
# Legacy = use bias field estimated from structural scans (only valid if structural collected in same session without any subject movement)
# SEBased = estimate bias field from SpinEchoFieldMap (only valid with both Pos and Neg SpinEcho)

GradientDistortionCoeffs="NONE" #no gradient correction unless we are provided with a .grad file 

#######################################
# Process inputs and config options from app


if [[ -z "${FW_INPUT_StructZip}" ]]; then
  echo -e "$CONTAINER  INPUT_DIR has no valid StructZip files!"
  exit 1
else
  StructZipFile="${FW_INPUT_StructZip}"
fi

if [[ -z "${FW_INPUT_fMRITimeSeries}" ]]; then
  echo -e "$CONTAINER  INPUT_DIR has no valid fMRITimeSeries files!"
  exit 1
else
  fMRITimeSeries="${FW_INPUT_fMRITimeSeries}"
fi

# Extract some info from .json saved in hcpstruct zip file
StructConfigFile="hcpstruct_config.json"
unzip -p ${StructZipFile} '*hcpstruct_config.json' > ${StructConfigFile}
hcpstruct_Subject=$(jq -r '.config.Subject // empty' ${StructConfigFile})
hcpstruct_RegName=$(jq -r '.config.RegName // empty' ${StructConfigFile})
if [[ -z "${hcpstruct_Subject}" ]]; then
  echo -e "$CONTAINER  ${StructZipFile} did not contain ${StructConfigFile}!"
  exit 1
fi

# Read necessary acquisition params from fMRI
DwellTime=$(print_decimal_number $(jq -r '.inputs["fMRITimeSeries"].object.info.EffectiveEchoSpacing // empty' ${CONFIG_FILE}))
pedirfMRI=$(jq -r '.inputs["fMRITimeSeries"].object.info.PhaseEncodingDirection // empty' ${CONFIG_FILE})
pedirfMRI=$( echo "$pedirfMRI" | tr "[ijk]" "[xyz]" )
UnwarpDir=${pedirfMRI}

if [[ -e "${FW_INPUT_fMRIScout}" ]]; then
  fMRISBRef="${FW_INPUT_fMRIScout}"
  #TODO: confirm parameters match fMRITimeSeries?
fi

if [[ -e "${FW_INPUT_GradientCoeff}" ]]; then
  GradientDistortionCoeffs="${FW_INPUT_GradientCoeff}"
  #TODO: add "siemens" vs "GE" to pipeline for gradient unwarping
  #GradientDistortionCoeffs_vendor="siemens"
fi

# For Siemens FieldMap, must include Magnitude and Phase inputs.  Extract deltaTE automatically
if [[ -e "${FW_INPUT_SiemensGREPhase}" ]] && [[ -e "${FW_INPUT_SiemensGREMagnitude}" ]]; then
  MagnitudeInputName="${FW_INPUT_SiemensGREMagnitude}"
  PhaseInputName="${FW_INPUT_SiemensGREPhase}"
  DistortionCorrection="SiemensFieldMap"
  
  #Ideally, FieldMap_Phase .json would contain EchoTime1 and EchoTime2
  #echotime1=$(jq -r '.inputs["SiemensGREPhase"].object.info.EchoTime1 // empty' ${CONFIG_FILE})
  #echotime2=$(jq -r '.inputs["SiemensGREPhase"].object.info.EchoTime2 // empty' ${CONFIG_FILE})
  
  echotime1=$(jq -r '.inputs["SiemensGREMagnitude"].object.info.EchoTime // empty' ${CONFIG_FILE})
  echotime2=$(jq -r '.inputs["SiemensGREPhase"].object.info.EchoTime // empty' ${CONFIG_FILE})
  
  if [[ -z "$echotime1" ]] || [[ -z "$echotime2" ]]; then
    echo -e "$CONTAINER  No EchoTime metadata found in FieldMap input file!  Exiting."
    exit 1
  elif [[ "$echotime1" == "$echotime2" ]]; then
    echo -e "$CONTAINER  EchoTime1 and EchoTime2 are the same (Please ensure Magnitude input is TE1)! Exiting."
    exit 1
  fi
  
  echotime1=$(print_decimal_number $echotime1)
  echotime2=$(print_decimal_number $echotime2)
  DeltaTE=$(echo "($echotime2 - $echotime1)*1000.0" | bc -l)
  
# For SpinEcho "TOPUP" FieldMap, must include both Pos and Neg phase encode
elif [[ -e "${FW_INPUT_SpinEchoNegative}" ]] && [[ -e "${FW_INPUT_SpinEchoPositive}" ]]; then
  
  SpinEchoPhase1="${FW_INPUT_SpinEchoNegative}"
  SpinEchoPhase2="${FW_INPUT_SpinEchoPositive}"

  pedirSE1=$(jq -r '.inputs["SpinEchoPositive"].object.info.PhaseEncodingDirection // empty' ${CONFIG_FILE})
  pedirSE2=$(jq -r '.inputs["SpinEchoNegative"].object.info.PhaseEncodingDirection // empty' ${CONFIG_FILE})
  pedirSE1=$( echo "$pedirSE1" | tr "[ijk]" "[xyz]" )
  pedirSE2=$( echo "$pedirSE2" | tr "[ijk]" "[xyz]" )
  
  if [[ -z "${pedirSE1}" ]]; then
    echo -e "$CONTAINER  SpinEchoPositive input is missing PhaseEncodingDirection metadata!"
    exit 1
  elif [[ -z "${pedirSE2}" ]]; then
    echo -e "$CONTAINER  SpinEchoNegative input data is missing PhaseEncodingDirection metadata!"
    exit 1
  elif [[ "${pedirSE1}" == "${pedirSE2}" ]]; then
    echo -e "$CONTAINER SpinEchoPositive and SpinEchoNegative have the same PhaseEncodingDirection (${pedirSE1})!"
    exit 1
  fi
  
  pedirfMRI_plane=$( echo "${pedirfMRI}" | sed -E 's/[-+]//g' )
  pedirSE_plane=$( echo "${pedirSE1}" | sed -E 's/[-+]//g' )
  
  if [[ "${pedirfMRI_plane}:${pedirSE1},${pedirSE2}" == "x:x,x-" ]] || [[ "${pedirfMRI_plane}:${pedirSE1},${pedirSE2}" == "y:y,y-" ]]; then
    SpinEchoPhaseEncodePositive="${SpinEchoPhase1}"
    SpinEchoPhaseEncodeNegative="${SpinEchoPhase2}"
  elif [[ "${pedirfMRI_plane}:${pedirSE1},${pedirSE2}" == "x:x-,x" ]] || [[ "${pedirfMRI_plane}:${pedirSE1},${pedirSE2}" == "y:y-,y" ]]; then
    SpinEchoPhaseEncodePositive="${SpinEchoPhase2}"
    SpinEchoPhaseEncodeNegative="${SpinEchoPhase1}"
    echo -e "$CONTAINER  SpinEcho phase-encoding directions were swapped. Continuing!"
  else
    echo -e "$CONTAINER  SpinEcho phase-encoding directions (${pedirSE1},${pedirSE2}) invalid or do not match fMRI acquisition plane (${pedirfMRI_plane})."
    exit 1
  fi
  
  DistortionCorrection="TOPUP"
  TopupDwellTime=$(print_decimal_number $(jq -r '.inputs["SpinEchoPositive"].object.info.EffectiveEchoSpacing // empty' ${CONFIG_FILE}))
  SEUnwarpDir="${pedirSE_plane}"
  
  #TODO: Double check DwellTime and TopupDwellTime and resolution too
  
elif [[ -e "${FW_INPUT_GeneralElectricFieldMap}" ]]; then
  #TODO: how do we handle GE fieldmap? where do we get deltaTE?
  echo -e "$CONTAINER  Cannot currently handle GeneralElectricFieldmap!"
  exit 1
  
  #GEB0InputName="${FW_INPUT_GeneralElectricFieldMap}"
  #DistortionCorrection="GeneralElectricFieldMap"
fi

# Install FreeSurfer license
if [[ -e "${FW_INPUT_FreeSurferLicense}" ]]; then
  echo -e "$CONTAINER Copying user-supplied FreeSurfer license file to ${FREESURFER_HOME}/license.txt"
  cp -f "${FW_INPUT_FreeSurferLicense}" ${FREESURFER_HOME}/license.txt
fi


#Maybe make the field Subject_Override, and use logic like:
#????
if [[ -z "${FW_CONFIG_Subject}" ]] || [[ $(toupper "${FW_CONFIG_Subject}") = "EMPTY" ]]; then
  Subject="${hcpstruct_Subject}"
else
  Subject="${FW_CONFIG_Subject}"
fi

if [[ -z "${FW_CONFIG_RegName}" ]] || [[ $(toupper "${FW_CONFIG_RegName}") = "EMPTY" ]]; then
  RegName="${hcpstruct_RegName}"
else
  RegName="${FW_CONFIG_RegName}"
fi

if [[ -z "${FW_CONFIG_fMRIName}" ]]; then
  echo -e "$CONTAINER  fMRIName cannot be empty!"
  exit 1
else
  # Output name (and prefix) for preprocessed data
  fMRIName="${FW_CONFIG_fMRIName}"
fi

MCType=$(toupper "${FW_CONFIG_MotionCorrection}")
case "$MCType" in
  MCFLIRT|FLIRT)
    #nothing
    ;;
  *)
    echo -e "$CONTAINER  MotionCorrection must be MCFLIRT or FLIRT!"
    exit 1
    ;;
esac

BiasCorrection=$(toupper "${FW_CONFIG_BiasCorrection}")
case "$BiasCorrection" in
  NONE|LEGACY)
    #nothing
    ;;
  SEBASED)
    if [[ "$DistortionCorrection" != "TOPUP" ]]; then
      echo -e "$CONTAINER  SE-Based BiasCorrection only available when providing Pos and Neg SpinEchoFieldMap scans"
      exit 1
    fi
    ;;
  *)
    echo -e "$CONTAINER  BiasCorrection must be NONE, Legacy, or SEBased!"
    exit 1
    ;;
esac

DOF_EPI2T1="${FW_CONFIG_AnatomyRegDOF}"
case "${DOF_EPI2T1}" in
  6|12)
    #nothing
    ;;
  *)
    echo -e "$CONTAINER  AnatomyRegDOF must be 6 or 12!"
    exit 1
    ;;
esac

# Some options that may become user-specified in the future, but use standard HCP values for now
GrayordinatesResolution="2"                       # Usually 2mm ("1.60" also available)
LowResMesh="32"                                   # Usually 32k vertices ("59" = 1.60mm)
GrayordinatesTemplate="91282_Greyordinates"       # (or 170494_Greyordinates = 1.60mm)

FinalfMRIResolution="2" #****config option?****** #generally "2", "1.60"
#UseJacobian=""                                      # append DC jacobian to bias correction? TRUE or FALSE. 
#Only recommended for TOPUP (default=TRUE for TOPUP, default=FALSE for GRE fieldmaps)

SmoothingFWHM=${FinalfMRIResolution}              # Smoothing during CIFTI surface and subcortical resampling

#######################################
# Additional pipeline inputs
TopupConfig="${HCPPIPEDIR_Config}/b02b0.cnf" #Topup config if using TOPUP, set to NONE if using regular FIELDMAP

GrayordinatesSpaceDIR="${HCPPIPEDIR_Templates}/${GrayordinatesTemplate}" #(Need to copy these in)

# Check templates selected via user inputs exist
if [[ ! -e "${GrayordinatesSpaceDIR}" ]]; then
  echo -e "$CONTAINER  Grayordinates directory not found: ${GrayordinatesSpaceDIR}!"
  exit 1
fi

################################################################################
# Unzip HCP-Structural outputs

echo -e "${CONTAINER} [$(timestamp)] Unzipping HCP-Structural zip"
unzip -q ${StructZipFile} -d ${StudyFolder}

# save list of files extracted from hcpstruct zip so we can remove them from output
# (specifically, list of ALL files that exist in OUTPUT_DIR at this point)
FilesToRemove=${OUTPUT_DIR}/to_delete.txt
( cd ${StudyFolder}; find ${Subject}/ -type f ) > ${FilesToRemove}

################################################################################
# Run GenericfMRIVolumeProcessingPipeline.sh

echo -e "${CONTAINER} [$(timestamp)] Starting: fMRI Volume Pipeline"

pipeline_status_code=0

set -x
${RUN_VOL} ${FSLDIR}/bin/fsl_sub ${QUEUE} ${FSLSUBOPTIONS} \
   ${HCPPIPEDIR}/fMRIVolume/GenericfMRIVolumeProcessingPipeline.sh \
    --path=$StudyFolder \
    --subject=$Subject \
    --fmriname=$fMRIName \
    --fmritcs=$fMRITimeSeries \
    --fmriscout=$fMRISBRef \
    --SEPhaseNeg=$SpinEchoPhaseEncodeNegative \
    --SEPhasePos=$SpinEchoPhaseEncodePositive \
    --fmapmag=$MagnitudeInputName \
    --fmapphase=$PhaseInputName \
    --fmapgeneralelectric=$GEB0InputName \
    --echospacing=$DwellTime \
    --echodiff=$DeltaTE \
    --unwarpdir=$UnwarpDir \
    --fmrires=$FinalfMRIResolution \
    --dcmethod=$DistortionCorrection \
    --gdcoeffs=$GradientDistortionCoeffs \
    --topupconfig=$TopupConfig \
    --biascorrection=$BiasCorrection \
    --mctype=${MCType} \
    --dof=${DOF_EPI2T1} \
    --printcom=$PRINTCOM
set +x

pipeline_status_code=$?

if [[ $pipeline_status_code == 0 ]]; then
  echo -e "${CONTAINER} [$(timestamp)] fMRI Volume Pipeline Success!"
else
  echo -e "${CONTAINER} [$(timestamp)] fMRI Volume Pipeline Failure!"
  exit 1
fi

################################################################################
# Run GenericfMRISurfaceProcessingPipeline.sh

echo -e "${CONTAINER} [$(timestamp)] Starting: fMRI Surface Pipeline"

set -x
${RUN_SURF} ${FSLDIR}/bin/fsl_sub ${QUEUE} ${FSLSUBOPTIONS} \
   ${HCPPIPEDIR}/fMRISurface/GenericfMRISurfaceProcessingPipeline.sh \
    --path="${StudyFolder}" \
    --subject=${Subject} \
    --fmriname=${fMRIName} \
    --lowresmesh=${LowResMesh} \
    --fmrires=${FinalfMRIResolution} \
    --smoothingFWHM=${SmoothingFWHM} \
    --grayordinatesres=${GrayordinatesResolution} \
    --regname=${RegName} \
    --printcom=$PRINTCOM
set +x

pipeline_status_code=$?

if [[ $pipeline_status_code == 0 ]]; then
  echo -e "${CONTAINER} [$(timestamp)] fMRI Surface Pipeline Success!"
else
  echo -e "${CONTAINER} [$(timestamp)] fMRI Surface Pipeline Failure!"
  exit 1
fi

################################################################################
# Generate HCP-Functional QC Images

echo -e "${CONTAINER} [$(timestamp)] Starting: Functional QC Image Generation"

qc_scene_root="${StudyFolder}/${Subject}"

qc_outputdir="${StudyFolder}"
mkdir -p ${qc_outputdir}

qc_image_root="${qc_outputdir}/${Subject}_${fMRIName}.hcpfunc_QC."

set -x
${RUN_QC} ${SCRIPT_DIR}/hcpfunc_qc_mosaic.sh \
  ${qc_scene_root} \
  ${fMRIName} \
  ${qc_image_root} > ${LogFileDirFull}/functionalqc.log

set +x

################################################################################
# Clean-up and prepare outputs

# Delete files that came from the HCP-Structural zip input
cd ${StudyFolder}
for f in $(cat ${FilesToRemove}); do
  rm -f $f
done
rm -f ${FilesToRemove}

# Delete extraneous preprocessing files
rm -rf ${StudyFolder}/${Subject}/${fMRIName}/OneStepResampling/prevols/
rm -rf ${StudyFolder}/${Subject}/${fMRIName}/OneStepResampling/postvols/
find ${StudyFolder}/${Subject}/${fMRIName}/MotionMatrices/ -name "*.nii.gz" -delete

# Add current gear config.json to output for reference in subsequent gears
# - For now, don't copy full input json since it might contain identifiers from DICOM etc
# - add/update .config.RegName since it might not have been included in config (pre-MSM availability)
# - add/update .config.Subject since it might later be pulled from other session metadata
# - This jq call does the value replacement, then selects just .config but stores it back into a 
#    new element called ".config" so the new file can be read as though it was flywheel config.json
OUTPUT_CONFIG_FILE=${StudyFolder}/${Subject}/${Subject}_${fMRIName}_hcpfunc_config.json 
jq -r '.config.RegName = "'$RegName'" | .config.Subject = "'$Subject'" | .config | {config: .}' $CONFIG_FILE > ${OUTPUT_CONFIG_FILE}

# If pipeline successful, zip outputs and clean up
outputzipname=${Subject}_${fMRIName}_hcpfunc.zip 
echo -e "${CONTAINER} [$(timestamp)] Zipping output file ${outputzipname}"
ziplistfile=${OUTPUT_DIR}/${outputzipname}.list.txt
rm -f ${ziplistfile} 
rm -f ${OUTPUT_DIR}/${outputzipname}
cd ${StudyFolder}
# include all remaining files in functional output zip
find ${Subject} -type f > ${ziplistfile}
cat ${ziplistfile} | zip ${OUTPUT_DIR}/${outputzipname} -@ > ${OUTPUT_DIR}/${outputzipname}.log
rm -f ${ziplistfile}

# zip pipeline logs
logzipname=pipeline_logs.zip
echo -e "${CONTAINER} [$(timestamp)] Zipping pipeline logs to ${logzipname}"
cd ${OUTPUT_DIR}
zip -r ${OUTPUT_DIR}/${logzipname} ${LogFileDir}/ > ${OUTPUT_DIR}/${logzipname}.log

echo -e "${CONTAINER} [$(timestamp)] Cleaning output directory"
rm -rf ${StudyFolder}/${Subject}/
rm -rf ${LogFileDirFull}/

exit $pipeline_status_code
